#version 460
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

shared uint _array_3PAIA[64];
shared uint _array_signed_3PAHA[64];

void main()
{
    uint _20 = atomicAdd(_array_3PAIA[gl_GlobalInvocationID.x], 1u);
    uint _23 = atomicAnd(_array_3PAIA[gl_GlobalInvocationID.x], 2u);
    uint _24 = atomicExchange(_array_3PAIA[gl_GlobalInvocationID.x], 3u);
    uint _26 = atomicMax(_array_3PAIA[gl_GlobalInvocationID.x], 4u);
    uint _28 = atomicMin(_array_3PAIA[gl_GlobalInvocationID.x], 5u);
    uint _30 = atomicOr(_array_3PAIA[gl_GlobalInvocationID.x], 6u);
    uint _32 = atomicXor(_array_3PAIA[gl_GlobalInvocationID.x], 7u);
    uint _35 = atomicMin(_array_signed_3PAHA[gl_GlobalInvocationID.x], 8u);
    uint _37 = atomicMax(_array_signed_3PAHA[gl_GlobalInvocationID.x], 9u);
}


#if 0
// LLVM disassembly
target datalayout = "e-m:e-p:32:32-i1:32-i8:32-i16:32-i32:32-i64:64-f16:32-f32:32-f64:64-n8:16:32:64"
target triple = "dxil-ms-dx"

@"\01?array@@3PAIA" = external addrspace(3) global [64 x i32], align 4
@"\01?array_signed@@3PAHA" = external addrspace(3) global [64 x i32], align 4

define void @main() {
  %1 = call i32 @dx.op.threadId.i32(i32 93, i32 0)
  %2 = getelementptr [64 x i32], [64 x i32] addrspace(3)* @"\01?array@@3PAIA", i32 0, i32 %1
  %3 = atomicrmw add i32 addrspace(3)* %2, i32 1 seq_cst
  %4 = atomicrmw and i32 addrspace(3)* %2, i32 2 seq_cst
  %5 = atomicrmw xchg i32 addrspace(3)* %2, i32 3 seq_cst
  %6 = atomicrmw umax i32 addrspace(3)* %2, i32 4 seq_cst
  %7 = atomicrmw umin i32 addrspace(3)* %2, i32 5 seq_cst
  %8 = atomicrmw or i32 addrspace(3)* %2, i32 6 seq_cst
  %9 = atomicrmw xor i32 addrspace(3)* %2, i32 7 seq_cst
  %10 = getelementptr [64 x i32], [64 x i32] addrspace(3)* @"\01?array_signed@@3PAHA", i32 0, i32 %1
  %11 = atomicrmw min i32 addrspace(3)* %10, i32 8 seq_cst
  %12 = atomicrmw max i32 addrspace(3)* %10, i32 9 seq_cst
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @dx.op.threadId.i32(i32, i32) #0

attributes #0 = { nounwind readnone }

!llvm.ident = !{!0}
!dx.version = !{!1}
!dx.valver = !{!2}
!dx.shaderModel = !{!3}
!dx.entryPoints = !{!4}

!0 = !{!"clang version 3.7 (tags/RELEASE_370/final)"}
!1 = !{i32 1, i32 0}
!2 = !{i32 1, i32 5}
!3 = !{!"cs", i32 6, i32 0}
!4 = !{void ()* @main, !"main", null, null, !5}
!5 = !{i32 4, !6}
!6 = !{i32 64, i32 1, i32 1}
#endif
#if 0
// SPIR-V disassembly
; SPIR-V
; Version: 1.3
; Generator: Unknown(30017); 21022
; Bound: 41
; Schema: 0
OpCapability Shader
OpMemoryModel Logical GLSL450
OpEntryPoint GLCompute %3 "main" %13
OpExecutionMode %3 LocalSize 64 1 1
OpName %3 "main"
OpName %9 "?array@@3PAIA"
OpName %10 "?array_signed@@3PAHA"
OpDecorate %13 BuiltIn GlobalInvocationId
%1 = OpTypeVoid
%2 = OpTypeFunction %1
%5 = OpTypeInt 32 0
%6 = OpConstant %5 64
%7 = OpTypeArray %5 %6
%8 = OpTypePointer Workgroup %7
%9 = OpVariable %8 Workgroup
%10 = OpVariable %8 Workgroup
%11 = OpTypeVector %5 3
%12 = OpTypePointer Input %11
%13 = OpVariable %12 Input
%14 = OpTypePointer Input %5
%16 = OpConstant %5 0
%18 = OpTypePointer Workgroup %5
%21 = OpConstant %5 2
%22 = OpConstant %5 1
%25 = OpConstant %5 3
%27 = OpConstant %5 4
%29 = OpConstant %5 5
%31 = OpConstant %5 6
%33 = OpConstant %5 7
%36 = OpConstant %5 8
%38 = OpConstant %5 9
%3 = OpFunction %1 None %2
%4 = OpLabel
OpBranch %39
%39 = OpLabel
%15 = OpAccessChain %14 %13 %16
%17 = OpLoad %5 %15
%19 = OpAccessChain %18 %9 %17
%20 = OpAtomicIAdd %5 %19 %21 %16 %22
%23 = OpAtomicAnd %5 %19 %21 %16 %21
%24 = OpAtomicExchange %5 %19 %21 %16 %25
%26 = OpAtomicUMax %5 %19 %21 %16 %27
%28 = OpAtomicUMin %5 %19 %21 %16 %29
%30 = OpAtomicOr %5 %19 %21 %16 %31
%32 = OpAtomicXor %5 %19 %21 %16 %33
%34 = OpAccessChain %18 %10 %17
%35 = OpAtomicSMin %5 %34 %21 %16 %36
%37 = OpAtomicSMax %5 %34 %21 %16 %38
OpReturn
OpFunctionEnd
#endif
